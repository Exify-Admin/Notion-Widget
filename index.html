<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" rel="stylesheet">

  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: transparent; color: #808080; }
    .wrapper{
      width:100%;
      max-width:1100px;
      margin:0 auto;
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(170px, 1fr));
      gap:12px;
      padding:12px;
      box-sizing:border-box;
    }
    .counter{ background:#e8e8e8; padding:16px 12px; border-radius:10px; text-align:center; }
    .count-title{ font-size:34px; font-weight:700; margin:10px 0 0; line-height:1.1; color:#4a4a4a; }
    .count-text{ font-size:13px; margin:8px 0 0; opacity:.9; color:#6a6a6a; }
    .fa-2x{ margin:0 auto; display:table; color:#4ad1e5; }
    .meta{ font-size:12px; opacity:.7; padding:0 12px 12px; box-sizing:border-box; text-align:center; }
    .error{ color:#b00020; opacity:.95; }
  </style>

  <script>
    // =========================
    // CONFIG — EDIT THESE
    // =========================
    const API_URL = "https://notion-widget-woad.vercel.app/api/notion-counts?key=k7Qm3p9Lx2R8v5N";

    // Poll rate (keep >= 10s to avoid twitch + overlapping)
    const REFRESH_MS = 15000;

    // Animation tuning (smooth + not sputtery)
    const FIRST_LOAD_DURATION_MS = 900;   // count up from 0 on load
    const UPDATE_DURATION_MS     = 650;   // count between changes
    const FRAME_MS               = 16;    // ~60fps
    const INSTANT_DELTA_MAX      = 2;     // if change is +/- 1 or 2, just snap (no animation)

    // Must match your Notion status names exactly
    const STATUS_ORDER = ["Queue", "In Progress", "Past Due", "Blocked", "Completed"];

    // =========================
    // HELPERS
    // =========================
    const fmt = (n) => Number(n).toLocaleString("en-US");
    const clampInt = (v) => {
      const n = Number.parseInt(v, 10);
      return Number.isFinite(n) ? Math.max(0, n) : 0;
    };

    function setMeta(text, isError) {
      const el = document.getElementById("meta");
      el.textContent = text;
      el.classList.toggle("error", !!isError);
    }

    async function fetchCountsPayload() {
      // cache: "no-store" helps the browser; Vercel caching is controlled server-side.
      const res = await fetch(API_URL, { cache: "no-store" });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`API failed (${res.status}): ${txt}`);
      }
      return await res.json(); // { counts, total, updatedAt }
    }

    function normalizeCounts(payload) {
      const raw = payload.counts || payload || {};
      const counts = {};
      for (const s of STATUS_ORDER) counts[s] = clampInt(raw[s]);
      return counts;
    }

    // =========================
    // PER-TILE ANIMATION ENGINE
    // - No jQuery / no setInterval stacking
    // - requestAnimationFrame (smooth)
    // - Cancels any in-flight animation per tile
    // - Snaps small changes instantly
    // =========================
    function animateNumber(el, from, to, durationMs) {
      from = clampInt(from);
      to   = clampInt(to);

      // Cancel any previous animation on this element
      const prevRaf = el._rafId;
      if (prevRaf) cancelAnimationFrame(prevRaf);
      el._rafId = null;

      // If tiny delta, just snap (prevents jitter on 4->5 etc.)
      if (Math.abs(to - from) <= INSTANT_DELTA_MAX || durationMs <= 0) {
        el.textContent = fmt(to);
        el._current = to;
        return;
      }

      const start = performance.now();
      const delta = to - from;

      // Ease-out for nicer feel (fast start, gentle stop)
      const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

      const step = (now) => {
        const t = Math.min(1, (now - start) / durationMs);
        const eased = easeOutCubic(t);
        const value = Math.round(from + delta * eased);
        el.textContent = fmt(value);
        el._current = value;

        if (t < 1) {
          el._rafId = requestAnimationFrame(step);
        } else {
          el.textContent = fmt(to);
          el._current = to;
          el._rafId = null;
        }
      };

      el._current = from;
      el.textContent = fmt(from);
      el._rafId = requestAnimationFrame(step);
    }

    function setInstantAll(counts) {
      document.querySelectorAll(".timer[data-status]").forEach((el) => {
        const status = el.getAttribute("data-status");
        const v = clampInt(counts[status]);
        el.textContent = fmt(v);
        el._current = v;
      });
    }

    function animateAllFromZero(counts) {
      document.querySelectorAll(".timer[data-status]").forEach((el) => {
        const status = el.getAttribute("data-status");
        const to = clampInt(counts[status]);
        animateNumber(el, 0, to, FIRST_LOAD_DURATION_MS);
      });
    }

    function animateOnlyChanged(prevCounts, nextCounts) {
      document.querySelectorAll(".timer[data-status]").forEach((el) => {
        const status = el.getAttribute("data-status");
        const prev = clampInt(prevCounts[status]);
        const next = clampInt(nextCounts[status]);

        if (prev === next) return;

        // If element is mid-animation, use its currently displayed value as "from"
        const currentDisplayed = clampInt((el.textContent || "").replace(/,/g, ""));
        const from = Number.isFinite(currentDisplayed) ? currentDisplayed : prev;

        animateNumber(el, from, next, UPDATE_DURATION_MS);
      });
    }

    // =========================
    // MAIN LOOP (no overlap)
    // =========================
    let lastCounts = null;
    let tickInFlight = false;

    async function tick() {
      if (tickInFlight) return;
      tickInFlight = true;

      try {
        const payload = await fetchCountsPayload();
        const counts = normalizeCounts(payload);

        if (!lastCounts) {
          // First load: count up from 0 (your request)
          animateAllFromZero(counts);
        } else {
          // Later: animate only changed tiles (up or down)
          animateOnlyChanged(lastCounts, counts);
        }

        lastCounts = { ...counts };

        const ts = payload.updatedAt ? new Date(payload.updatedAt) : new Date();
        setMeta(`Last checked: ${ts.toLocaleString()}`, false);
      } catch (err) {
        console.error(err);
        setMeta("Failed to load counts. Check API URL / key / Vercel env vars.", true);

        // Don't thrash numbers on failure; leave last good values.
        // If there were no good values yet, show zeros once.
        if (!lastCounts) {
          const zeros = Object.fromEntries(STATUS_ORDER.map(s => [s, 0]));
          setInstantAll(zeros);
          lastCounts = zeros;
        }
      } finally {
        tickInFlight = false;
      }
    }

    // Start on DOM ready
    window.addEventListener("DOMContentLoaded", () => {
      tick();
      setInterval(tick, REFRESH_MS);
    });
  </script>
</head>

<body>
  <div class="wrapper">
    <div class="counter">
      <i class="fas fa-stream fa-2x"></i>
      <h2 class="timer count-title" data-status="Queue">0</h2>
      <p class="count-text">Queue</p>
    </div>

    <div class="counter">
      <i class="fas fa-tools fa-2x"></i>
      <h2 class="timer count-title" data-status="In Progress">0</h2>
      <p class="count-text">In Progress</p>
    </div>

    <div class="counter">
      <i class="fas fa-exclamation-triangle fa-2x"></i>
      <h2 class="timer count-title" data-status="Past Due">0</h2>
      <p class="count-text">Past Due</p>
    </div>

    <div class="counter">
      <i class="fas fa-ban fa-2x"></i>
      <h2 class="timer count-title" data-status="Blocked">0</h2>
      <p class="count-text">Blocked</p>
    </div>

    <div class="counter">
      <i class="fas fa-check-circle fa-2x"></i>
      <h2 class="timer count-title" data-status="Completed">0</h2>
      <p class="count-text">Completed</p>
    </div>
  </div>

  <div id="meta" class="meta">Loading…</div>
</body>
</html>
